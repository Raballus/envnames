---
title: "Overview of the envnames package"
author: "Daniel Mastropietro"
date: "`r Sys.Date()`"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{Overview of the envnames package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r echo=FALSE}
library(envnames)
```

The main goal of this package is to overcome the limitation of the built-in `environmentName()` function from the base package which does not return the name of an environment unless it is a package, a namespace or a pre-defined environment (e.g. the global environment, the base environment). The `environmentName()` function returns an empty string for user-defined environments.

As mentioned in the [documentation for the environment function](https://stat.ethz.ch/R-manual/R-devel/library/base/html/environment.html):  
*System environments, such as the base, global and empty environments, have names as do the package and namespace environments and those generated byÂ attach(). Other environments can be named by giving a "name" attribute, but this needs to be done with care as environments have unusual copying semantics.*

The envnames package solves this problem by creating a lookup table that maps environment names to their memory addresses. Using this lookup table, it is possible to retrieve the name of any environment where an object resides.

During the development process, additional tools were added to this basic functionality, which includes:

- extending the functionality of the `exists` function by searching objects inside user-defined environments (in addition to the global environment and packages). This is done by the `obj_find` function.  
- simplifying the process of retrieving the calling function name and the stack of calling functions currently provided by `sys.call`. This is done by the `get_fun_calling` and `get_fun_calling_chain` functions.  
- retrieving the memory address of an object. This is done by the `get_obj_address` function.  

The following sections give examples of these functionalities.

All function names in this package use the underscore convention (e.g. `environment_name`, `get_obj_address`)

## Define environments and retrieve their name with `environment_name()`
In this section we illustrate the use of the `environmen_name()` function. To put in context, its signature is the following:  
`environment_name(env, envir = NULL, envmap = NULL, byaddress = TRUE, ignore = NULL)`.

Let's define a couple of environments and nested environments.

```{r}
env1 <- new.env()
env_of_envs <- new.env()
with(env_of_envs, env21 <- new.env())
```

Now let's retrieve their names using `environment_name()`. This may sound trivial because we are already typing the environment name! However, look at the output from the second call: it contains also the name of the environment where the requested environment (`env21`) is defined. Below we will also see even more useful examples when we search for objects.

```{r}
environment_name(env1)
environment_name(env21)
```

In this case the output is a named array, but if we know in which environment an environment is defined, we can specify it in the `envir` parameter and get their name directly:

```{r}
environment_name(env1, envir=globalenv())
environment_name(env21, envir=env_of_envs)
```

Suppose now that we define another environment that points to one of the above environments.

```{r}
e <- env_of_envs$env21
```

Now, let's retrieve its name:

```{r}
environment_name(e)
```

We see that we get all environments that point to the same memory address. We could disable this behaviour of matching environments by memory address by calling:

```{r}
environment_name(e, byaddress=FALSE)
```

Finally, if we try to retrieve the environment name of a non-existing environment, we get `NULL`.

```{r}
environment_name(non_existing_env)
```

## Check the existence of an object with `obj_find()`

## Retrieve the function calling stack with `get_fun_calling_chain()`
Following is an example that shows the difference between using the `sys.call` function already available in base R and the package function `get_fun_calling_chain` to retrieve the calling stack. 

In particular note:  
- How easy it is to check what the calling function is (just do a string comparison: `get_fun_calling() == "env1$f"`). When using `sys.call` we first need to parse the output before making such a comparison. See [this link](http://stackoverflow.com/questions/15595478/how-to-get-the-name-of-the-calling-function-inside-the-called-routine) for more information.  
- We get a data frame containing the chain of calling functions, from most recent call to least recent.  
- Note however that the parameters used in each call are not stored nor shown. In order to retrieve this information, use `sys.call`.  

Let's show the example...

1) First define a couple of environments:

```{r}
env1 <- new.env()
env2 <- new.env()
```

2) Now define an example function `h` to be called by two different functions `f` defined in two different user-environments. This function `h` does something different depending on which function `f` called it.

```{r}
h <- function(x, silent=TRUE) {
  fun_calling_chain = get_fun_calling_chain(silent=silent)
  cat("\nCalling chain information inside function", get_fun_calling(0), ":\n")
  print(fun_calling_chain)

  # Do a different operation on input parameter x depending on the calling function
  fun_calling = get_fun_calling()
  if (fun_calling == "env1$f") { x = x + 1 }
  else if (fun_calling == "env2$f") { x = x + 2 }

  return(x)
}
```

3) Define the two calling functions `f`, respectively in environments `env1` and `env2`:

```{r}
with(env1,
  f <- function(x, silent=TRUE) {
    fun_calling_chain = get_fun_calling_chain()
    return(h(x, silent=silent))
  }
)

with(env2,
  f <- function(x, silent=TRUE) {
    fun_calling_chain = get_fun_calling_chain()
    return(h(x, silent=silent))
  }
)
```

4) Run these functions `f` and take note of their output.

- Output from `env1$f()`:

```{r, echo=FALSE}
silent = FALSE
x = 0
cat("\nWhen h(x) is called by env1$f(x=", x, ") the output is: ", env1$f(x, silent=silent), "\n", sep="")
```

- Output from `env2$f()`:

```{r, echo=FALSE}
silent = FALSE
x = 0
cat("\nWhen h(x) is called by env2$f(x=", x, ") the output is: ", env2$f(x, silent=silent), "\n", sep="")
```

Note how easy it was to decide what action to take based on the `f()} function calling `h()} and perform a different operation.

## Retrieve the memory address of an object with `get_obj_address()}




## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
