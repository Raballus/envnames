---
title: "Overview of the envnames package"
author: "Daniel Mastropietro"
date: "`r Sys.Date()`"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{Overview of the envnames package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r echo=FALSE}
library(envnames)
```

The main goal of this package is to overcome the limitation of the built-in `environmentName()` function from the base package which does not return the name of an environment unless it is a package, a namespace or a pre-defined environment (e.g. the global environment, the base environment). The `environmentName()` function returns an empty string for user-defined environments.

As mentioned in the [documentation for the environment function](https://stat.ethz.ch/R-manual/R-devel/library/base/html/environment.html):  
*System environments, such as the base, global and empty environments, have names as do the package and namespace environments and those generated byÂ attach(). Other environments can be named by giving a "name" attribute, but this needs to be done with care as environments have unusual copying semantics.*

The envnames package solves this problem by creating a lookup table that maps environment names to their memory addresses. Using this lookup table, it is possible to retrieve the name of any environment where an object resides.

During the development process, additional tools were added to this basic functionality, which includes:

- extending the functionality of the `exists()` function by searching objects inside user-defined environments and nested environments (in addition to the global environment and packages), as well as searching objects that are the results of expressions. This is done by the `obj_find()` function.  
- simplifying the process of retrieving the calling function name and the stack of calling functions currently provided by `sys.call()`. This is done by the `get_fun_calling()` and `get_fun_calling_chain()` functions.  
- retrieving the memory address of an object. This is done by the `get_obj_address()` function.  

The following sections give examples of these functionalities.

Package convention: all function names in this package use the underscore convention (e.g. `environment_name()`, `get_obj_address()`)

## Define environments and retrieve their name with `environment_name()`
In this section we illustrate the use of the `environmen_name()` function. To put in context, its signature is the following:  
`environment_name(env, envir = NULL, envmap = NULL, byname = FALSE, ignore = NULL)`.

### Examples
Let's define a couple of environments and nested environments.

```{r}
env1 <- new.env()
env_of_envs <- new.env()
with(env_of_envs, env21 <- new.env())
```

Now let's retrieve their names using `environment_name()`. This may sound trivial because we are already typing the environment name! However, look at the output from the second call: it contains also the name of the environment where the requested environment (`env21`) is defined. Below we will also see even more useful examples when we search for objects.

```{r}
environment_name(env1)
environment_name(env21)
```

In this case the output is a named array, but if we know in which environment an environment is defined, we can specify it in the `envir` parameter and get their name directly:

```{r}
environment_name(env1, envir=globalenv())
environment_name(env21, envir=env_of_envs)
```

Suppose now that we define another environment that points to one of the above environments.

```{r}
e <- env_of_envs$env21
```

Now, let's retrieve its name:

```{r}
environment_name(e)
```

We see that we get all environments that point to the same memory address. We could disable this behaviour of matching environments by memory address by calling:

```{r}
environment_name(e, byname=TRUE)
```

Finally, if we try to retrieve the environment name of a non-existing environment, we get `NULL`.

```{r}
environment_name(non_existing_env)
```

Now suppose we have a memory address and we would like to know if that memory address corresponds to an environment.
We can simply call `environment_name()` with the memory address as argument, as follows:

```{r}
env1_obj_address = get_obj_address(env1)
environment_name(env1_obj_address)
```

Of course, in practice we would not call the `get_obj_address()` function to get the environment's memory address; we would simply type in the memory address we are after. Note that this memory address must be a 16-digit address enclosed in `< >`, as in: `"<0000000011D7A150>"`.

## Check the existence of an object with `obj_find()`
With the `obj_find()` function we can check if an object exists in any existing environment. All environments --including global, packages and user-defined environments-- are crawled to search for the object. This includes any environment that are defined within other environments. The function returns a character array with all the environments where the object was found.

Objects to search for can be specified either as a symbol or as a string. Ex: `obj_find(x)` and `obj_find("x")` both look for an object called "x". They can also be the result of an expression as in `v[1]`.

The function returns `NULL` if the object is not found or if the expression is invalid. For instance `obj_find(unquote(quote(x)))` returns `NULL` because the `unquote()` function does not exist in R.

The signature of the function is the following:
`obj_find(obj, envir = NULL, globalsearch = TRUE, n = 0, silent = TRUE)`

### Examples
Let's define a couple of objects in the environments already defined above:

```{r}
x <- 5
env1$x <- 3
with(env_of_envs, env21$y <- 5)
with(env1, {
  vars_as_string <- c("x", "y", "z")
  vars_quoted <- c(quote(x), quote(y), quote(z))
})
```

Now let's look for these objects:
```{r}
obj_find(x)
obj_find(y)
obj_find(vars_as_string)
```

Let's also look for the objects defined in `vars_as_string` and `vars_quoted`.
```{r}
obj_find(env1$vars_as_string[1])  # Here we are looking for the object 'x'
obj_find(env1$vars_as_string[2])  # Here we are looking for the object 'y'
obj_find(env1$vars_as_string[3])  # Here we are looking for the object 'z' which does not exist
```

or using `sapply()`:

```{r}
with(env1, sapply(vars_as_string, obj_find) )
sapply(env1$vars_quoted, obj_find)
```
We can also search for objects given as a symbol:

```{r}
obj_find(as.name("x"))
```

Finally, we can also search for objects defined in packages:

```{r}
obj_find(aov)
```

## Retrieve the function calling stack with `get_fun_calling_chain()`
Following is an example that shows the difference between using the `sys.call` function already available in base R and the package function `get_fun_calling_chain` to retrieve the calling stack. 

In particular note:  
- How easy it is to check what the calling function is (just do a string comparison: `get_fun_calling() == "env1$f"`). When using `sys.call` we first need to parse the output before making such a comparison. See [this link](http://stackoverflow.com/questions/15595478/how-to-get-the-name-of-the-calling-function-inside-the-called-routine) for more information.  
- We get a data frame containing the chain of calling functions, from most recent call to least recent.  
- Note however that the arguments used in each call are not stored nor shown. In order to retrieve this information, use `sys.call`.  

### Example

1) First define a couple of environments:

```{r}
env11 <- new.env()
env12 <- new.env()
```

2) Now define an example function `h` to be called by two different functions `f` defined in two different user-environments. This function `h` does something different depending on which function `f` called it.

```{r}
h <- function(x, silent=TRUE) {
  fun_calling_chain = get_fun_calling_chain(silent=silent)
  cat("\nCalling chain information inside function", get_fun_calling(0), ":\n")
  print(fun_calling_chain)

  # Do a different operation on input parameter x depending on the calling function
  fun_calling = get_fun_calling()
  if (fun_calling == "env11$f") { x = x + 1 }
  else if (fun_calling == "env12$f") { x = x + 2 }

  return(x)
}
```

3) Define the two calling functions `f`, respectively in environments `env11` and `env12`:

```{r}
with(env11,
  f <- function(x, silent=TRUE) {
    fun_calling_chain = get_fun_calling_chain()
    return(h(x, silent=silent))
  }
)

with(env12,
  f <- function(x, silent=TRUE) {
    fun_calling_chain = get_fun_calling_chain()
    return(h(x, silent=silent))
  }
)
```

4) Run these functions `f` and take note of their output.

- Output from `env11$f()`:

```{r, echo=FALSE}
silent = FALSE
x = 0
cat("\nWhen h(x) is called by env11$f(x=", x, ") the output is: ", env11$f(x, silent=silent), "\n", sep="")
```

- Output from `env12$f()`:

```{r, echo=FALSE}
silent = FALSE
x = 0
cat("\nWhen h(x) is called by env12$f(x=", x, ") the output is: ", env12$f(x, silent=silent), "\n", sep="")
```

Note how easy it was to decide what action to take based on the `f()` function calling `h()` and perform a different operation.

## Retrieve the memory address of an object with `get_obj_address()`
Following are examples of using the `get_obj_address()` function to retrieve the memory address of an object. The object can be given either as a symbol or as an expression. In the latter case, the memory address of the result of the expression is returned. If the result is another expression, the process is not continued: just the memory address of such expression is returned.

The object is first searched for using `obj_find()` and if it exists, its memory address is returned as a named array containing the names of all the environments where the object is found. If the object is not found, `NULL` is returned.

### Examples

The following two calls return the same result:

```{r}
get_obj_address(x)
with(env1, get_obj_address(x))
```

Note especially the last case, where calling `get_obj_address()` from within the `env1` environment still searches for the object everywhere.

We can restrict the memory address returned by making the environment where the object is located explicit --by either using the `$` notation or the `envir` parameter of `get_obj_address()`. In this case only the address of the specified object is returned, even if other objects with the same name exist within the specified environment. A few examples follow:

```{r}
get_obj_address(env1$x)
get_obj_address(x, envir=env1)
with(env1, get_obj_address(x, envir=env1))
```

Note there is a slight difference between calling `get_obj_address()` using the `$` notation and calling it with the `envir=` parameter: in the latter case, the result is an _unnamed_ array.    

&nbsp;
&nbsp;

Suppose now the object is an expression referencing three potential existing objects as strings, more specifically an array:

```{r}
vars = c("x", "y", "nonexistent")
get_obj_address(vars[1], envir=env1)
sapply(vars, get_obj_address)
```

(recall that environment `e` points to the same environment as `env_of_envs$env21`)

We can check that the memory address is correct by running the internal function `envnames:::address()` which calls a C function that retrieves the memory address of a variable:

```{r}
envnames:::address(env1$x)
envnames:::address(e$y)
```

WARNING: If we call `envnames:::address()` on a non-existent object inside an environment to which we refer using the `$` notation, we still get a memory address and this is the memory address of `NULL`. In fact the following calls give the same result:

```{r}
envnames:::address(env1$nonexistent)
envnames:::address(NULL)
```
However, this is not the case if we use the `get_obj_address()` function as it returns `NULL` when the object is not found:

```{r}
get_obj_address(env1$nonexistent)
```
