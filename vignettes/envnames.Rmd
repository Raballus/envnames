---
title: "Overview of the envnames package"
author: "Daniel Mastropietro"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Overview of the envnames package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

>> FROM README.MD IN GITHUB
The main goal of this package is to overcome the limitation of the built-in environmentName() function from the base package which does not return the name of an environment unless it is a package, a namespace or a pre-defined environment (e.g. the global environment, the base environment, the empty environment).

The envnames package solves this problem by creating a lookup table that maps environment names to their memory addresses. Using this lookup table, it is possible to retrieve the name of any environment where an object resides or to retrieve the environment and function name of the calling function.

See the following post as motivation for building the package: [https://stat.ethz.ch/pipermail/r-help/2010-July/245646.html]
<<


The envnames package was written with the purpose of keeping track of the *names* of user-defined environments, which in base `R` cannot be retrieved (i.e. the `environmentName` function returns an empty string when run on a user-defined environment).

As mentioned in the [documentation](https://stat.ethz.ch/R-manual/R-devel/library/base/html/environment.html) for the `environment` function:  
*System environments, such as the base, global and empty environments, have names as do the package and namespace environments and those generated byÂ attach(). Other environments can be named by giving a "name" attribute, but this needs to be done with care as environments have unusual copying semantics.*

During the development process, additional tools were added to this basic functionality, which includes:

- extending the functionality of the `exists` function by searching objects inside user-defined environments (in addition to the global environment and packages). This is done by the `obj_find` function.
- simplifying the process of retrieving the calling function name and the stack of calling functions currently provided by `sys.call`. This is done by the `get_fun_calling` and `get_fun_calling_chain` functions.
- retrieving the memory address of an object. This is done by the `get_obj_address` function.

The following sections give examples of these functionalities.


## Retrieve function calling stack
Following is an example that shows the difference between using the `sys.call` function already available in base R and the package function `get_fun_calling_chain` to retrieve the calling stack. 

In particular note:  
- How easy it is to check what the calling function is (just do a string comparison: `get_fun_calling() == "env1$f"`)  
- 

```{r CallingStack}
library(envnames)

env1 <- new.env()
env2 <- new.env()

# Define a function 'f' in two different user-environments that calls another function 'h' defined in the global environment
#### FUNCTION h(): the called function
h <- function(x, silent=TRUE) {
  fun_calling_chain = get_fun_calling_chain()
  fun_calling = get_fun_calling()

  # Do a different operation on input parameter x depending on the calling function
  if (fun_calling == "env1$f") { x = x + 1 }
  else if (fun_calling == "env2$f") { x = x + 2 }
  
  # Do the same using sys.call(): much more complicated!
  # cat("Returned value by sys.call:\n")
  #print(sys.call(-1))
  # cat("\tas a string\n")
  #print(str(sys.call(-1)))
  # print(deparse(sys.call(1)))
  # Extract the name of the calling function (very complicated!!)
  fun_calling_syscall = gsub(pattern="^([A-Za-z0-9]+)(\\({1})(.*)(\\){1})$",replacement="\\1",x=deparse(sys.call(-1)))
    ## Ref: http://stackoverflow.com/questions/15595478/how-to-get-the-name-of-the-calling-function-inside-the-called-routine
  #print(sapply(sys.calls(), "[[", 1)[[2]])
  #print(class(sapply(sys.calls(), "[[", 1)[[2]]))
  # The following apparently doesn't work: I get the error in grep(): "argument is of length 0"
  #if (grep("env1$f", sys.call(sys.parent(1)))) { x = x + 1 }
  #else if (grep("env2$f", sys.call(sys.parent(1)))) { x = x + 2 }
  if (fun_calling_syscall == "env1$f") { x = x + 1 }
  else if (fun_calling_syscall == "env2$f") { x = x + 2 }

  if (!silent) {
    cat("\n")
    cat("NOW INSIDE FUNCTION '", get_fun_calling(0), "':\n", sep="")
    # Show difference between sys.call() and get_fun_calling()
    cat("1A) This is the information shown by sys.call() about the current function (the output is a 'call' object):\n")
    print(sys.call(sys.parent(0)))
    cat("1B) This is the information shown by envnames::get_fun_calling() about the current function (the output is simply a string):\n")
    cat(get_fun_calling(0), "\n")
    cat("\n")
    cat("2A) This is the environment name of the calling function returned by the built-in environmentName() function:\n")
    cat("\"", environmentName(parent.frame()), "\"\n", sep="")
    cat("2B) This is the environment name of the calling function returned by envnames::get_fun_calling():\n")
    cat(fun_calling, "\n")
    cat("\n")
    cat("3) This is the Calling chain:\n")
    print(fun_calling_chain)
  }
  
  return(x)
}

#### FUNCTION env1$f(): one of the calling functions
with(env1,
  f <- function(x, silent=TRUE) {
    fun_calling_chain = get_fun_calling_chain()

    if (!silent) {
      cat("NOW INSIDE FUNCTION '", get_fun_calling(0), "':\n", sep="")
      cat("\tCalling chain is:\n")
      print(fun_calling_chain)
      cat("\n")
    }

    return(h(x, silent=silent))
  }
)

#### FUNCTION env2$f(): one of the calling functions
with(env2,
  f <- function(x, silent=TRUE) {
    fun_calling_chain = get_fun_calling_chain()
    
    if (!silent) {
      cat("\nCalling chain inside function", get_fun_calling(0), ":\n")
      print(fun_calling_chain)
    }

    return(h(x, silent=silent))
  }
)

#### RUN the example
silent = FALSE
x = 0
cat("When h(x) is called by env1$f(x=", x, ") the output is: ", env1$f(x, silent=silent), "\n", sep="")
cat("When h(x) is called by env2$f(x=", x, ") the output is: ", env2$f(x, silent=silent), "\n", sep="")
```








## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
