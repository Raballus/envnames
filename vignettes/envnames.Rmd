---
title: "Overview of the envnames package"
author: "Daniel Mastropietro"
date: "`r Sys.Date()`"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{Overview of the envnames package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The main goal of this package is to overcome the limitation of the built-in `environmentName()` function from the base package which does not return the name of an environment unless it is a package, a namespace or a pre-defined environment (e.g. the global environment, the base environment). The `environmentName()` function returns an empty string for user-defined environments.

As mentioned in the [documentation for the environment function](https://stat.ethz.ch/R-manual/R-devel/library/base/html/environment.html):  
*System environments, such as the base, global and empty environments, have names as do the package and namespace environments and those generated byÂ attach(). Other environments can be named by giving a "name" attribute, but this needs to be done with care as environments have unusual copying semantics.*

The envnames package solves this problem by creating a lookup table that maps environment names to their memory addresses. Using this lookup table, it is possible to retrieve the name of any environment where an object resides.

During the development process, additional tools were added to this basic functionality, which includes:

- extending the functionality of the `exists` function by searching objects inside user-defined environments (in addition to the global environment and packages). This is done by the `obj_find` function.  
- simplifying the process of retrieving the calling function name and the stack of calling functions currently provided by `sys.call`. This is done by the `get_fun_calling` and `get_fun_calling_chain` functions.  
- retrieving the memory address of an object. This is done by the `get_obj_address` function.  

The following sections give examples of these functionalities.

All function names in this package use the underscore convention (e.g. `environment_name`, `get_obj_address`, ...)

## Retrieve the functions calling stack
Following is an example that shows the difference between using the `sys.call` function already available in base R and the package function `get_fun_calling_chain` to retrieve the calling stack. 

In particular note:  
- How easy it is to check what the calling function is (just do a string comparison: `get_fun_calling() == "env1$f"`). When using `sys.call` we first need to parse the output before making such a comparison. See [this link](http://stackoverflow.com/questions/15595478/how-to-get-the-name-of-the-calling-function-inside-the-called-routine) for more information.  
- We get a data frame containing the chain of calling functions, from most recent call to least recent.  
- Note however that the parameters used in each call are not stored nor shown. In order to retrieve this information, use `sys.call`.  

Let's show the example...

1) First define a couple of environments:

```{r}
library(envnames)

env1 <- new.env()
env2 <- new.env()
```

2) Now define an example function `h` to be called by two different functions `f` defined in two different user-environments. This function `h` does something different depending on which function `f` called it.

```{r}
h <- function(x, silent=TRUE) {
  fun_calling_chain = get_fun_calling_chain(silent=silent)
  cat("\nCalling chain information inside function", get_fun_calling(0), ":\n")
  print(fun_calling_chain)

  # Do a different operation on input parameter x depending on the calling function
  fun_calling = get_fun_calling()  # This is equivalent to directly retrieving fun_calling_chain["1", "envfun"]
  fun_calling = fun_calling_chain["1", "envfun"]
  if (fun_calling == "env1$f") { x = x + 1 }
  else if (fun_calling == "env2$f") { x = x + 2 }

  return(x)
}
```

3) Define the two calling functions `f`, respectively in environments `env1` and `env2`:

```{r}
with(env1,
  f <- function(x, silent=TRUE) {
    fun_calling_chain = get_fun_calling_chain()
    return(h(x, silent=silent))
  }
)

with(env2,
  f <- function(x, silent=TRUE) {
    fun_calling_chain = get_fun_calling_chain()
    return(h(x, silent=silent))
  }
)
```

4) Run these functions `f` and take note of their output.

- Output from `env1$f()`:

```{r, echo=FALSE}
silent = FALSE
x = 0
cat("\nWhen h(x) is called by env1$f(x=", x, ") the output is: ", env1$f(x, silent=silent), "\n", sep="")
```

- Output from `env2$f()`:

```{r, echo=FALSE}
silent = FALSE
x = 0
cat("\nWhen h(x) is called by env2$f(x=", x, ") the output is: ", env2$f(x, silent=silent), "\n", sep="")
```







## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
