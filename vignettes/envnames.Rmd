---
title: "Use envnames to work with named environments and find objects anywhere"
author: "Daniel Mastropietro"
date: "`r Sys.Date()`"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{Overview of the envnames package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r echo=FALSE}
#library(knitr)
#opts_chunk$set(include=TRUE, warning=FALSE)
```


```{r echo=FALSE}
library(envnames)
```

# Introduction

The main goal of this package is to overcome the limitation of the `environmentName()` function in the base package which does not return the name of an environment unless it is a package, a namespace or a pre-defined environment (e.g. the global environment, the base environment). In fact, the `environmentName()` function returns an *empty string* when the argument is a user-defined environment.

As mentioned in the **[documentation for the `environment()` function in the base package](https://stat.ethz.ch/R-manual/R-devel/library/base/html/environment.html)**:  
*System environments, such as the base, global and empty environments, have names as do the package and namespace environments and those generated by attach(). Other environments can be named by giving a "name" attribute, but this needs to be done with care as environments have unusual copying semantics.*

The envnames package solves this problem by creating a lookup table that maps environment names to their memory addresses. Using this lookup table, it is possible to retrieve the name of any environment where an object resides, including function execution environments.

Why do we care about knowing the name of user-defined environments? That piece of information may be handy under the following scenarios:

- working in a package where user-defined environments have been defined in a nested structure.  
This package facilitates the navigation through those environments and their connection between them (reducing the use of `ls()` to see what is inside an environment that is solely identified by a memory address).
For more information and examples, see the `get_env_names()` function that returns a map of currently defined environments and the way they are connected or nested.  
- debugging an application.  
This package makes it easier to retrieve variables in different environments; for instance, retrieve the value of a variable in the parent environment to the environment where the debugger is currently positioned.
For more information and examples, see function `get_obj_value()`.  

Apart from this core functionaliy, additional tools were added during the package development process which include:

- an enhancement of the built-in `exists()` function with the capability of searching objects *recursively* --i.e. in  environments defined inside *other* environments--, as well as searching objects that are the *result of expressions*. This functionality is provided by the `obj_find()` function.  
- a simplification of the output obtained when retrieving the calling function name and the stack of calling functions, currently provided by the built-in function `sys.call()`. This functionality is provided by the `get_fun_calling()` and `get_fun_calling_chain()` functions which return simple strings or array of strings with the function names of interest.  
IMPORTANT: these functions may _not_ give enough information when the affected fuctions are actually _overloaded methods_, since the method's parameters are not part of the string returned by the functions.  
- the retrieval of the memory address of an object. This functionality is provided by the `get_obj_address()` function.  

Currently the package has 11 functions directly accessible to the user.

*Naming convention*: Function names are all small caps and the underscore is used to separate keywords (e.g. `environment_name()`, `get_obj_address()`, etc.)

# Description of selected functions

This section describes the functionality of 4 selected functions (sorted by relevance with the package topic):  
- `environment_name`, to get the name of user-defined and execution environments.  
- `obj_find`, to find an object in the workspace and recursively within environments.  
- `get_fun_calling_chain`, to get the function calling stack displayed in an easier format than `sys.calls`.  
- `get_obj_address`, to get the memory address of an object by first looking for it (using `obj_find`).   

The following 7 functions are not covered by the vignette:  
- `address`, which returns the memory address of an existing object.  
- `get_env_names`, which returns the address-name lookup table, the core element of the package that allows the magic to happen.  
- `get_fun_calling`, which returns the last function call in the calling chain returned by `get_fun_calling_chain`.  
- `get_fun_env`, which returns the execution environment(s) of function matching a name or a memory address.  
- `get_fun_name` -> to be described in upcoming versions  
- `get_obj_name` -> to be described in upcoming versions  
- `get_obj_value` -> to be described in upcoming versions  

The title of each sub-section is a sentence stating what can be accomplished with the presented function.

## Retrieve name of user-defined and function exec environments: `environment_name()`
The `environment_name()` function extends the functionality of `environmentName()` in the base package by also retrieving the name of user-defined environments and function execution environments.
Although the name of an environment can be easily retrieved with `deparse(substitute(env1))` where `env1` is a user-defined environment, the most useful
scenario for the use of `environment_name()` is when some function tells us that an object is part of a user-defined environment, but this environment
is only given as a *memory address* (as in e.g. `<environment 0x000000000437fb40>`). In this scenario, `environment_name()` can tell us the *name* of the
environment having that memory address.  

The address to name conversion also works for *function execution environments*.

The signature of the function is the following:  
`environment_name(env, envir = NULL, envmap = NULL, matchname = FALSE, ignore = NULL)`.

### Examples

#### Let's start with a few object definitions
We define a couple of environments and nested environments.

```{r DefineEnvironments}
env1 <- new.env()
env_of_envs <- new.env()
with(env_of_envs, env21 <- new.env())
```

So the environment `env21` is *nested* in environment `env_of_envs`.

#### Basic operation
Let's retrieve the names of the environments just defined using the `environment_name()` function. This may sound trivial because we are already typing the environment name! However, look at the output from the second call: it contains the *path* to the environment being searched for stating that `env21` is found inside environment `env_of_envs`.

```{r GetEnvironmentNames, warning=FALSE}
environment_name(env1)
environment_name(env21)
```

If we already know in which environment the environment we are after is defined, we can specify it in the `envir` parameter and get their name without any path information:

```{r GetEnvironmentNamesSpecifyingLocation, warning=FALSE}
environment_name(env1, envir=globalenv())
environment_name(env21, envir=env_of_envs)
```

#### More advanced examples
Suppose now that we define another environment that points to one of the already defined environments.

```{r DefineAnotherEnvironmentThatPointsToAnExistingEnvironment}
e <- env_of_envs$env21
```

Now, let's retrieve its name:

```{r GetTheEnvironmentNameOfThisNewEnvironment}
environment_name(e)
```

What we get is the names of *all* the environments (in alphabetical order) that point to the same memory address. We can disable such behaviour of matching environments by memory address by setting the `matchname` parameter to `TRUE` so that the returned environments must match both the memory address *and* the name:

```{r CallEnvironmentNameWithMatchNameTRUE}
environment_name(e, matchname=TRUE)
```

Note that the result of this last call could actually return *more than one environment* when environments sharing the same name (`e` in the above example) are defined in different environments *all pointing to the same environment*. In the above example we could have this situation if we defined an environment called `"e"` in environment `env_of_envs` pointing to environment `e` defined in the global environment (with the command `env_of_envs$e <- e`).

Finally, if we try to retrieve the environment name of a non-existing environment, we get `NULL`.

```{r CallEnvironmentNameOnNonExistingEnvironment, warning=FALSE}
environment_name(non_existing_env)
```

#### Retrieving the environment name associated with a memory address
Now suppose we have a memory address and we would like to know if that memory address represents an environment.
We can simply call `environment_name()` with the memory address as argument, as shown in the following example:

```{r ConvertMemoryAddressToEnvironmentName}
env1_obj_address = get_obj_address(env1)
environment_name(env1_obj_address)
```

Of course, in practice we would not call the `get_obj_address()` function to get the environment's memory address; we would simply type in the memory address we are after. Note that this memory address can be given either as:  

- a 16-digit address, e.g. `"0000000011D7A150"`  
- a 18-digit address, e.g. `"0x0000000011D7A150"`  
- either the 16-digit or 18-digit address enclosed in `< >`, e.g. `"<0000000011D7A150>"` or `"<0x0000000011D7A150>"`  
- a 18-digit address preceeded by the `environment: ` keyword and enclosed in `< >`, e.g.: `"<environment: 0x0000000011D7A150>"`  

The latter format is particularly useful when copy & pasting the result of querying an environment object, for example when typing `env1` at the `R` command prompt, assuming that `env1` is a user-defined environment.  

If the memory address does not match any of the above formats or does not represent an environment `environment_name()` returns `NULL`. Ex:

```{r EnvironmentNameOfNonEnvironmentMemoryAddressIsNULL}
x = 2
environment_name(get_obj_address(x))
```

#### Retrieving the execution environment of a function
If called inside a function, `environment_name()` returns the name of the function and the environment where the function is defined.
The following example shows this use of `environment_name()`.

```{r GetExecutionEnvironmentName}
with(env1,
  f <- function() {
    cat("1) We are inside function", environment_name(), "\n")
  }
)
env1$f()
```

## Check the existence of an object: `obj_find()`
With the `obj_find()` function we can check if an object exists in any existing environment. All environments --including system environments, packages, user-defined environments, and optionally function execution environments-- are crawled to search for the object. This includes any environments that are defined _within_ other environments, which represents an enhancement of the built-in `exists()` function. The function returns a character array with all the environments where the object has been found.

Objects to search for can be specified either as a symbol or as a string. Ex: `obj_find(x)` and `obj_find("x")` both look for an object called "x". They can also be the result of an expression as in `v[1]`.

The function returns `NULL` if the object is not found or if the expression is invalid. For instance `obj_find(unquote(quote(x)))` returns `NULL` because the `unquote()` function does not exist in R.

The signature of the function is the following:
`obj_find(obj, envir = NULL, envmap = NULL, globalsearch = TRUE, n = 0, return_address = FALSE, include_functions = FALSE, silent = TRUE)`

### Examples

#### Let's start with a few object definitions
We define a couple of objects in the environments previously defined:

```{r DefineObjectsInEnvironments}
x <- 5
env1$x <- 3
with(env_of_envs, env21$y <- 5)
with(env1, {
  vars_as_string <- c("x", "y", "z")
})
```

#### Basic operation
Now let's look for these objects:
```{r LookForObjects1, warning=FALSE}
cat("Object 'x' found in the following environments:\n")
obj_find(x)
cat("Object 'y' found in the following environments:\n")
obj_find(y)
```

(if your are seeing more environments than you expected in the above output, recall that environment `e` points to the same environment as `env_of_envs$env21`)

```{r LookForObjects2}
cat("Object 'vars_as_string' found in the following environments:\n")
obj_find(vars_as_string)
```

Let's also look for the objects defined in `vars_as_string` and `vars_quoted`.
```{r LookForObjectsWhoseNamesAreGivenInArray}
cat(paste("Object '", env1$vars_as_string[1], "' found in the following environments:\n"))
obj_find(env1$vars_as_string[1])  # Here we are looking for the object 'x'
cat(paste("Object '", env1$vars_as_string[2], "' found in the following environments:\n"))
obj_find(env1$vars_as_string[2])  # Here we are looking for the object 'y'
cat(paste("Object '", env1$vars_as_string[3], "' found in the following environments:\n"))
obj_find(env1$vars_as_string[3])  # Here we are looking for the object 'z' which does not exist
```

or using `sapply()`:

```{r LookForObjectsUsingSAPPLY}
cat("The objects defined in the 'env1$vars_as_string' array are found
    in the following environments:\n")
with(env1, sapply(vars_as_string, obj_find) )
```

Note how calling `obj_find()` from within the `env1` environment still searches for the objects everywhere. This is because parameter `globalsearch` is set to `TRUE`. If we set it to `FALSE` and we add `envir=env1` as searching environment, we would get:  

```{r LookForObjectsUsingSAPPLYNoGlobalSearch}
cat("The objects defined in the 'env1$vars_as_string' array are found
    in the following environments (no globalsearch):\n")
with(env1, sapply(vars_as_string, obj_find, globalsearch=FALSE, envir=env1) )
```
NOTE: It's important to add parameter `envir=env1`; if we don't add it, the objects are *not* found because the parent environmnt of the call to `obj_find()` is *not* `env1` but the `sapply()` execution environment.

We can also search for objects given as a symbol:

```{r LookForObjectAsASymbol}
cat("Object 'x' found in the following environments:\n")
obj_find(as.name("x"))
```

Finally, we can also search for objects defined in packages:

```{r LookForObjectsDefinedInPackages}
cat("Object 'aov' found in the following environments:\n")
obj_find(aov)
```

## Retrieve the function calling chain (stack): `get_fun_calling_chain()`
Following is an example that shows the difference between using the built-in `sys.call()` function and the package function `get_fun_calling_chain()` to retrieve the calling stack. 

In particular note:  
- How easy it is to check what the calling function is (just do a string comparison as in e.g. `get_fun_calling() == "env1$f"`). On the contrary, when using `sys.call()` we first need to parse the output before making such a comparison. See **[this link](http://stackoverflow.com/questions/15595478/how-to-get-the-name-of-the-calling-function-inside-the-called-routine)** for more details.  
- We get a data frame containing the chain of calling functions, from the most recent call to least recent, including function parameters if desired.  

The signature of the function is the following:
`get_fun_calling_chain(n = NULL, showParameters = FALSE, silent = TRUE)`

### Examples

#### Let's start with a few object definitions
1) First we define a couple of new environments:

```{r DefineTwoEnvironments}
env11 <- new.env()
env12 <- new.env()
```

2) Now we define an example function `h` to be called by two different functions `f` defined in two different user-environments. This function `h` does something different depending on which function `f` was responsible for calling it.

```{r DefineFunctionH}
with(globalenv(), 
h <- function(x, silent=TRUE) {
  fun_calling_chain = get_fun_calling_chain(silent=silent)

  # Do a different operation on input parameter x depending on the calling function
  fun_calling = get_fun_calling(showParameters=FALSE)
  if (fun_calling == "env11$f") { x = x + 1 }
  else if (fun_calling == "env12$f") { x = x + 2 }

  return(x)
}
)
```

3) Finally we define the two functions `f` that call `h`, respectively in environments `env11` and `env12`:

```{r DefineTwoFunctionsFInSeparateEnvironments}
with(env11,
  f <- function(x, silent=TRUE) {
    fun_calling_chain = get_fun_calling_chain()
    return(h(x, silent=silent))
  }
)

with(env12,
  f <- function(x, silent=TRUE) {
    fun_calling_chain = get_fun_calling_chain()
    return(h(x, silent=silent))
  }
)
```

### Basic operation
We now run these functions `f` and take note of their output.

- Output from `env11$f()`:

```{r RunFunctionF1, echo=FALSE}
silent = FALSE
x = 0
cat("\nWhen h(x) is called by env11$f(x=", x, ") the output is: ", env11$f(x, silent=silent), "\n", sep="")
```

- Output from `env12$f()`:

```{r RunFunctionF2, echo=FALSE}
silent = FALSE
x = 0
cat("\nWhen h(x) is called by env12$f(x=", x, ") the output is: ", env12$f(x, silent=silent), "\n", sep="")
```

Note how easy it was (by using just a string comparison) to decide what action to take based on the `f()` function calling `h()` and perform a different operation.

## Retrieve the memory address of an object: `get_obj_address()`
Following are examples of using the `get_obj_address()` function to retrieve the memory address of an object. The object can be given either as a symbol or as an expression. In the latter case, the memory address of the result of the expression is returned. If the result is another expression, the process stops, i.e. the memory address of such expression is returned.

Internally this funcion first calls `obj_find()` to look for the object (using `globalsearch=TRUE`) and then retrieves the object's memory address, showing the name of all the environments where the object was found, or `NULL` if the object is not found.  

The signature of the function is the following:
`get_obj_address(obj, envir = NULL, envmap = NULL, n = 0, include_functions = FALSE)`

### Examples
The following two calls return the same result:

```{r GetObjectAddress1}
cat("Output of 'get_obj_address(x)':\n")
get_obj_address(x)
cat("\nOutput of 'with(env1, get_obj_address(x))':\n")
with(env1, get_obj_address(x))
```

Note especially the last case, where calling `get_obj_address()` from within the `env1` environment still searches for the object everywhere.

We can restrict the memory address returned by making the environment where the object is located explicit --by either using the `$` notation or the `envir` parameter of `get_obj_address()`. In this case only the address of the specified object is returned, even if other objects with the same name exist within the specified environment. A few examples follow:

```{r GetObjectAddress2}
get_obj_address(env1$x)
get_obj_address(x, envir=env1)
with(env1, get_obj_address(x, envir=env1))
```

Note there is a slight difference between calling `get_obj_address()` using the `$` notation and calling it with the `envir=` parameter: in the latter case, the result is an _unnamed_ array.    

&nbsp;
&nbsp;

Suppose now the object is an expression referencing three potential existing objects as strings, more specifically an array:

```{r GetNonExistentObjectAddress}
vars = c("x", "y", "nonexistent")
get_obj_address(vars[1], envir=env1)
sapply(vars, get_obj_address)
```

(if your are seeing more environments than you expected in the above output, recall that environment `e` points to the same environment as `env_of_envs$env21`)

We can check that the memory address is correct by running the internal function `envnames:::address()` which calls a C function that retrieves the memory address of a variable:

```{r CheckMemoryAddressIsCorrect}
envnames:::address(env1$x)
envnames:::address(e$y)
```

WARNING: If we call `envnames:::address()` on a non-existent object inside an environment to which we refer using the `$` notation, we still get a memory address and this is the memory address of `NULL`. In fact the following calls give the same result:

```{r MemoryAddressOfNULL}
envnames:::address(env1$nonexistent)
envnames:::address(NULL)
```
However, this is not the case if we use the `get_obj_address()` function as it returns `NULL` when the object is not found:

```{r MemoryAddressOfNonExistentIsNULL}
get_obj_address(env1$nonexistent)
```

# Summing up
We have described the following 4 functions of the `envnames` package and shown examples of using them:  

- `environment_name()` to retrieve the name of an environment. This function extends the functionality of the built-in `environmentName()` function by retrieving:  
    - the name of a user-defined environment  
    - the name and path to environments defined inside other environments  
    - the name and path to the function associated to an execution environment  
    - the name of the environment associated to a memory address  
  
- `obj_find()` to find an object in the workspace. This function extends the functionality of the built-in `exists()` function by:  
    - searching for the object in user-defined environments  
    - searching for the object recursively (i.e. in environments defined inside other environments)  
  
- `get_fun_calling_chain()` to get the stack of calling functions. This function returns the stack information in a manner that is much simpler than the built-in `sys.calls()` function, making it easier to check the _names_ of the calling functions.  

- `get_obj_address()` to retrieve the memory address of an object. This function gives a functionality that is not available in base R. Note that the `data.table` package also provides a function called `address()` to retrieve the memory address of an object; however the object is _not searched for in the whole workspace_ as is the case with the `get_obj_address()` in this package.  

We have *not* described the other 7 functions in the package:  
- `address` -> the basic functionality used by the presented `get_obj_address`  
- `get_env_names` -> to be described in upcoming versions  
- `get_fun_calling` -> similar to the presented `get_fun_calling_chain`   
- `get_fun_env` -> to be described in upcoming versions  
- `get_fun_name` -> to be described in upcoming versions  
- `get_obj_name` -> to be described in upcoming versions  
- `get_obj_value` -> to be described in upcoming versions  
